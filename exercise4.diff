diff --git a/object.cc b/object.cc
index 3e6c761..fe0b19b 100644
--- a/object.cc
+++ b/object.cc
@@ -1,4 +1,5 @@
 #include "object.hh"
+#include <algorithm>
 
 #ifdef USE_JET_FITTING
 #include "jet-wrapper.hh"
@@ -21,9 +22,7 @@ void Object::draw(const Visualization &vis) const {
   glPolygonOffset(1, 1);
 
   if (vis.show_solid || vis.show_wireframe) {
-    if (vis.type == VisType::PLAIN)
-      glColor3d(1.0, 1.0, 1.0);
-    else if (vis.type == VisType::ISOPHOTES) {
+    if (vis.type == VisType::ISOPHOTES) {
       glBindTexture(GL_TEXTURE_2D, vis.current_isophote_texture);
       glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
       glEnable(GL_TEXTURE_2D);
@@ -37,6 +36,12 @@ void Object::draw(const Visualization &vis) const {
       glEnable(GL_TEXTURE_1D);
     }
     for (auto f : mesh.faces()) {
+        if (vis.type == VisType::PLAIN) {
+            if(std::find(vis.specialFaces.begin(), vis.specialFaces.end(), f) != vis.specialFaces.end())
+                glColor3d(1.0, 0.0, 0.0);
+            else
+                glColor3d(1.0, 1.0, 1.0);
+        }
       glBegin(GL_POLYGON);
       for (auto v : f.vertices()) {
         if (vis.type == VisType::MEAN)
diff --git a/viewer.cc b/viewer.cc
index 647f1c5..e3ac3d8 100644
--- a/viewer.cc
+++ b/viewer.cc
@@ -1,4 +1,5 @@
 #include <QtGui/QKeyEvent>
+#include <QtWidgets>
 
 #include "bezier.hh"
 #include "mesh.hh"
@@ -206,6 +207,9 @@ void Viewer::postSelection(const QPoint &p) {
 void Viewer::keyPressEvent(QKeyEvent *e) {
   if (e->modifiers() == Qt::NoModifier)
     switch (e->key()) {
+    case Qt::Key_Q:
+        this->findAndColorSpecialTriangles();
+        break;
     case Qt::Key_R:
       for (auto o : objects)
         o->reload();
@@ -385,6 +389,66 @@ void Viewer::updateMeanMinMax() {
   vis.mean_max = std::max(mean[k ? n-k : n-1], 0.0);
 }
 
+double triangleArea(const BaseMesh::Point& p0, const BaseMesh::Point& p1, const BaseMesh::Point& p2) {
+    BaseMesh::Point v1 = p1 - p0;
+    BaseMesh::Point v2 = p2 - p0;
+    return 0.5 * ((v1 % v2).norm());
+}
+
+double triangleCircumference(const BaseMesh::Point& p0, const BaseMesh::Point& p1, const BaseMesh::Point& p2) {
+    double side1 = (p1 - p0).norm();
+    double side2 = (p2 - p1).norm();
+    double side3 = (p0 - p2).norm();
+    return side1 + side2 + side3;
+}
+
+void Viewer::popupDialog(double maxAreaCircumference, double minCircumferenceArea){
+    auto dlg = std::make_unique<QDialog>(this);
+    dlg->setWindowTitle("Exercise no.4 specific data");
+    auto layout = std::make_unique<QVBoxLayout>();
+    auto label1 = std::make_unique<QLabel>("Circumference of the triangle with the maximum area: " + QString::number(maxAreaCircumference));
+    layout->addWidget(label1.get());
+    auto label2 = std::make_unique<QLabel>("Area of the triangle with the minimum circumference: " + QString::number(minCircumferenceArea));
+    layout->addWidget(label2.get());
+    auto okButton = std::make_unique<QPushButton>("OK");
+    connect(okButton.get(), &QPushButton::clicked, dlg.get(), &QDialog::accept);
+    layout->addWidget(okButton.get());
+    dlg->setLayout(layout.release());
+    dlg->exec();
+}
+
+void Viewer::findAndColorSpecialTriangles() {
+    double maxArea = -1.0f; BaseMesh::FaceHandle maxAreaFace; double maxAreaCircumference = 0.0f;
+    double minCircumference = std::numeric_limits<double>::max(); BaseMesh::FaceHandle minCircumferenceFace; double minCircumferenceArea = 0.0f;
+    for (auto o : objects){
+        const auto &mesh = o->baseMesh();
+        for (BaseMesh::FaceIter f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it) {
+            BaseMesh::FaceVertexIter fv_it = mesh.cfv_iter(*f_it);
+            BaseMesh::Point p0 = mesh.point(*fv_it); ++fv_it;
+            BaseMesh::Point p1 = mesh.point(*fv_it); ++fv_it;
+            BaseMesh::Point p2 = mesh.point(*fv_it);
+
+            double area = triangleArea(p0, p1, p2);
+            double circumference = triangleCircumference(p0, p1, p2);
+
+            if (area > maxArea) {
+                maxArea = area;
+                maxAreaFace = *f_it;
+                maxAreaCircumference = circumference;
+            }
+            if (circumference < minCircumference) {
+                minCircumference = circumference;
+                minCircumferenceFace = *f_it;
+                minCircumferenceArea = area;
+            }
+        }
+    }
+    popupDialog(maxAreaCircumference, minCircumferenceArea);
+    vis.specialFaces.clear();
+    vis.specialFaces.push_back(maxAreaFace);
+    vis.specialFaces.push_back(minCircumferenceFace);
+}
+
 void Viewer::setupCamera() {
   double large = std::numeric_limits<double>::max();
   Vector box_min(large, large, large), box_max(-large, -large, -large);
diff --git a/viewer.hh b/viewer.hh
index 1e475c2..ac11980 100644
--- a/viewer.hh
+++ b/viewer.hh
@@ -41,6 +41,8 @@ protected:
 private:
   void updateMeanMinMax();
   void setupCamera();
+  void findAndColorSpecialTriangles();
+  void popupDialog(double maxAreaCircumference, double minCircumferenceArea);
 
   std::vector<std::shared_ptr<Object>> objects;
   Visualization vis;
diff --git a/visualization.hh b/visualization.hh
index b88bf87..0064a4c 100644
--- a/visualization.hh
+++ b/visualization.hh
@@ -24,6 +24,7 @@ struct Visualization {
   // Flags
   VisType type;
   bool show_control_points, show_solid, show_wireframe;
+  std::vector<BaseMesh::FaceHandle> specialFaces;
 
   // Mean curvature
   double mean_min, mean_max, cutoff_ratio;
